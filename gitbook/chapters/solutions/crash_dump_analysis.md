# Crash Dump Analysis

## Description

A crash dump file is provided as input which was generated when an executable program crashed during runtime. The task requires extracting the executable from the crash dump and avoiding the cause of crash.

## Solution

In order to process the crash dump, it is first required to identify the file format for the crash dump. This was done by using a hex editor to visualize the first few bytes of the crash dump file:

```bash
$ xxd crash.dmp | head -n 10
0000000: 4d44 4d50 93a7 016b 0d00 0000 2000 0000  MDMP...k.... ...
0000010: 0000 0000 fe5c 094f 2618 0400 0000 0000  .....\.O&.......
0000020: 0300 0000 3400 0000 8402 0000 1100 0000  ....4...........
0000030: 4c00 0000 b802 0000 0400 0000 2002 0000  L........... ...
0000040: 0403 0000 1300 0000 a002 0000 2405 0000  ............$...
0000050: 0900 0000 3003 0000 9c22 0000 1000 0000  ....0...."......
0000060: a00f 0000 fc12 0000 0600 0000 a800 0000  ................
0000070: dc01 0000 0700 0000 3800 0000 bc00 0000  ........8.......
0000080: 0f00 0000 e800 0000 f400 0000 0c00 0000  ................
0000090: 7801 0000 8411 0000 0000 0000 0000 0000  x...............

```

The **MDMP** magic keyword indicates that the file is in [WinDBG][1] Minidump format. This file can be opened in WinDBG and the executable that crashed can be extracted using relevant WinDBG commands.

List loaded modules including executable:

```
0:000> lm
start    end        module name
00400000 0040e000   Stub       (deferred)             
77f10000 77f59000   gdi32      (deferred)             
7c800000 7c8f6000   kernel32   (deferred)             
7c900000 7c9af000   ntdll      (pdb symbols)          c:\symbols\ntdll.pdb\1751003260CA42598C0FB326585000ED2\ntdll.pdb
7e410000 7e4a1000   user32     (deferred)             
```

The start and end address of the executable in crash dump can be identified as *0x00400000* and *0x0040e000*

In order to reconstruct the executable, we need to extract the content of this memory range from the crash dump file:

```
0:000> .writemem C:\tmp\1.mem 00400000 0040e000   
Writing e001 bytes............................
```

Additionally the cause of the crash can be identified as *Access Violation* due to invalid address loaded in the [Instruction Pointer][2] EIP register.

```
(a60.73c): Access violation - code c0000005 (first/second chance not available)
eax=0000978f ebx=00000001 ecx=a1840000 edx=82839b00 esi=00000000 edi=fffffffe
eip=deadbabe esp=0012feec ebp=0012ff30 iopl=0         nv up ei ng nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00010286
deadbabe ??              ???

0:000> r @eip
eip=deadbabe
```

### PE File Reconstruction from Memory Image

The extracted memory content can be verified to be a valid PE executable image using a hex editor and inspecting the header bytes or by using a tool such as CFF Explorer that recognizes the PE file format:

![Neo Hexeditor](../../images/crashdump_neohex1.png "NeoHex")

However this memory content cannot be run as a PE executable directly as it is in a form known as  **Loaded PE**. This means the memory content is processed by the Operating System's PE Loader and loaded as per *VirtualAddress* offset of section headers. The PE section data for each section is at a distance of *VirtualAddress* bytes from the base as defined in its section header. However for a PE executable file, the section data should be *PointerToRawData* bytes from the start of the file. In order to *fix* this image we need to move PE section data for each section from *VirtualAddress* offset from base to *PointerToRawData* offset from base of file. This can be done either by writing a C program or using a library that understands PE file format such as [Metasm][3].

The following Ruby script can fix the extracted file and prepare a *runnable* executable from it.

```ruby
$:.unshift("C:\\Lib\\metasm")
require 'metasm'

if __FILE__ == $0
	pe = Metasm::LoadedPE.load(File.binread(ARGV[0]), 0x00400000)
	pe.decode_header
	pe.decode_imports
	
	pe.cpu	# CPU needs a reference to initialize correctly
	pe.invalidate_header
	pe.encode_file("1.exe")
end
```


[1]: <https://msdn.microsoft.com/en-in/library/windows/hardware/ff551063(v=vs.85).aspx>

[2]: <https://en.wikipedia.org/wiki/X86_assembly_language>

[3]: <http://metasm.cr0.org/
