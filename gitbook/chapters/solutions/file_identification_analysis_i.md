# File Identification and Analysis - I

## Description

A compressed PE executable file *a.exe* is provided as input. The task is to decompress the executable file and find a secret string available in the file.

## Solution

The compressed executable was analysed in [IDA Pro][3]. However IDA was unable to identify strings in the executable. This is because the PE compressor packed the executable in such a way that all strings are transformed into a compressed form. The executable is required to be decompressed in order to extract strings from the executable.

![IDA 1](../../images/fileid_ida1.png "IDA")

In order to unpack or decompress a compressed executable, it is first required to identify the packer or compressor used in the sample. The [PEiD][1] tool can be used for this purpose which can identify multiple executable packers and crypters.

![PEiD 1](../../images/peid1.png "PEiD")

![PEiD 2](../../images/peid2.png "PEiD")

PEiD identifies the sample to be packed with [UPX][2]. While most malware packers and crypters do not support unpacking by themseves, UPX is a standard PE compression tool and is not meant exclusively for code protection or hiding anything. For this reason, UPX by itself supports decompressing an executable that is compressed by UPX. We can use UPX tool to decompress the sample executable:

![UPX](../../images/upx_unpack1.png "UPX")

Finally the decompressed sample can be analyzed in IDA Pro to find the desired string:

![IDA 2](../../images/fileid_ida2.png "IDA")

## Alternative Solution: Manual Extraction

We start by looking at the entrypoint of the packed executable in debugger:

<center><img src='../../images/upx_disasm1.png'></img></center>

We see that the entrypoint saves value of all registers using the *pusha* instruction. In order to find an appropriate epilogue, we search for *popa* instruction assuming that at somepoint in code, the saved values will be restored before transferring control to Original Entrypoint (OEP). We set a breakpoint at the *popa* instruction and execute the sample till the breakpoint is hit:

<center><img src='../../images/upx_disasm2.png'></img></center>

On breakpoint hit, we can see the subsequent *jmp* instruction points to newly generated code which should be the unpacked code we are looking for:

<center><img src='../../images/upx_before_oep.png'></img></center>

We then single-step to the OEP code and create a new executable from memory using [OllyDumpEx](https://low-priority.appspot.com/ollydumpex/) plugin:

<center><img src='../../images/upx_ollydump.png'></img></center>

Finally we fix the Import Address Table (IAT) of the dumped executable using the [Scylla](https://github.com/NtQuery/Scylla) plugin:

<center><img src='../../images/upx_scylla.png'></img></center>

At this point we have successfully unpacked the UPX packed executable manually. This can be verified by loading the newly created executable in IDA pro:

<center><img src='../../images/upx_unpacked.png'></img></center>


[1]: <http://www.softpedia.com/get/Programming/Packers-Crypters-Protectors/PEiD-updated.shtml>

[2]: <http://upx.sourceforge.net/>

[3]: <https://www.hex-rays.com/products/ida/>
